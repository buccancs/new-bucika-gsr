package com.multisensor.recording.util

import android.content.Context
import android.util.Log
import com.multisensor.recording.testutils.BaseUnitTest
import io.mockk.*
import io.mockk.impl.annotations.MockK
import org.junit.*
import org.junit.Assert.*
import java.io.File

/**
 * Unit tests for the Logger utility class.
 * Tests logging functionality without requiring actual file I/O.
 */
class LoggerTest : BaseUnitTest() {

    @get:Rule
    val mockKRule = io.mockk.junit4.MockKRule(this)

    @MockK
    private lateinit var context: Context
    
    @MockK
    private lateinit var mockFile: File

    private lateinit var logger: Logger

    @Before
    override fun setUp() {
        super.setUp()
        
        // Mock Android Log calls since we're in unit test environment
        mockkStatic(Log::class)
        every { Log.v(any(), any(), any()) } returns 0
        every { Log.d(any(), any(), any()) } returns 0
        every { Log.i(any(), any(), any()) } returns 0
        every { Log.w(any(), any(), any()) } returns 0
        every { Log.e(any(), any(), any()) } returns 0
        
        // Setup context mocks
        every { context.getExternalFilesDir(any()) } returns mockFile
        every { context.filesDir } returns mockFile
        every { mockFile.exists() } returns true
        every { mockFile.mkdirs() } returns true
        every { mockFile.absolutePath } returns "/test/logs"
        every { mockFile.parentFile } returns mockFile
        
        logger = Logger(context)
    }

    @After
    override fun tearDown() {
        super.tearDown()
        unmockkStatic(Log::class)
    }

    @Test
    fun test_logger_creation() {
        // Given: Logger is created with context
        
        // When: Logger is initialized
        // Then: Logger should be created successfully
        assertNotNull("Logger should be created", logger)
    }

    @Test
    fun test_info_logging() {
        // Given: Logger is initialized
        
        // When: Logging info message
        logger.info("Test info message")
        
        // Then: Log.i should be called
        verify { Log.i("MultiSensorRecording", "Test info message", null) }
    }

    @Test
    fun test_error_logging_with_exception() {
        // Given: An exception occurs
        val exception = RuntimeException("Test exception")
        
        // When: Logging error with exception
        logger.error("Test error", exception)
        
        // Then: Log.e should be called with exception
        verify { Log.e("MultiSensorRecording", "Test error", exception) }
    }

    @Test
    fun test_debug_logging() {
        // Given: Logger is initialized
        
        // When: Logging debug message
        logger.debug("Debug message")
        
        // Then: Log.d should be called
        verify { Log.d("MultiSensorRecording", "Debug message", null) }
    }

    @Test
    fun test_verbose_logging() {
        // Given: Logger is initialized
        
        // When: Logging verbose message
        logger.verbose("Verbose message")
        
        // Then: Log.v should be called
        verify { Log.v("MultiSensorRecording", "Verbose message", null) }
    }

    @Test
    fun test_warning_logging() {
        // Given: Logger is initialized
        
        // When: Logging warning message
        logger.warning("Warning message")
        
        // Then: Log.w should be called
        verify { Log.w("MultiSensorRecording", "Warning message", null) }
    }

    @Test
    fun test_get_current_log_file_path() {
        // Given: Logger is initialized
        
        // When: Getting current log file path
        val path = logger.getCurrentLogFilePath()
        
        // Then: Path should be returned (may be null initially)
        // This is acceptable as file logging may not be immediately initialized
        assertTrue("Path should be string or null", path == null || path is String)
    }

    @Test
    fun test_log_cleanup() {
        // Given: Logger is initialized
        
        // When: Performing cleanup
        logger.cleanup()
        
        // Then: Cleanup should complete without exception
        assertTrue("Cleanup should succeed", true)
    }

    @Test
    fun test_get_available_log_files() {
        // Given: Logger is initialized
        
        // When: Getting available log files
        val files = logger.getAvailableLogFiles()
        
        // Then: A list should be returned
        assertNotNull("Files list should not be null", files)
        assertTrue("Files should be a list", files is List)
    }

    @Test
    fun test_system_info_logging() {
        // Given: Logger is initialized
        
        // When: Logging system info
        logger.logSystemInfo()
        
        // Then: System info should be logged (verify info call was made)
        verify(atLeast = 1) { Log.i("MultiSensorRecording", any(), any()) }
    }
}