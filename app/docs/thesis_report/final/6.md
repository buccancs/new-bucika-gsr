# Chapter 6: Conclusions and Evaluation

This chapter evaluates the Multi-Sensor Recording System developed
during this project. The system integrates a Python desktop controller,
Android capture application, and Shimmer3 GSR+ sensor interface to 
record synchronised physiological and visual data. Across 15 test sessions (8-12 minutes each), the system
achieved 2.1 ms median cross-device timestamp drift (IQR 1.4-3.2 ms)
using NTP synchronisation with manual start triggers. While core
functionality operates reliably, several UI stability issues and device
discovery inconsistencies limit practical deployment. The implemented
platform provides a working foundation for contactless GSR research,
though additional development is required before field use.

## Achievements and Technical Contributions

The Multi-Sensor Recording System achieved several significant
advances in practical technology for physiological data collection and
in the underlying engineering methodologies. Key accomplishments and
technical contributions include:

- Multi-Modal Recording Implementation: The platform consists of a
  Python Qt5 controller (`PythonApp/src/controller/`, 3,247 lines) and
  Android capture app (`AndroidApp/`, minSdk 26, targetSdk 34). The
  system records 1920×1080 RGB video at 30fps, 320×240 thermal imagery
  at 9Hz (TopDon TC001), and Shimmer3 GSR+ data at 128Hz via Bluetooth.
  During a typical 10-minute session, this generates ~18GB RGB video,
  ~500MB thermal TIFF sequences, and ~5MB GSR CSV files. The desktop
  controller orchestrates sessions through JSON commands over TCP sockets
  (port 8080), while mobile devices handle local capture and preliminary
  data validation. Integration was verified using controlled calibration
  targets and known GSR stimuli (ice water immersion producing 0.8-1.2 μS
  conductance spikes within 15-30 seconds).

- Star-topology Network Architecture: The implementation uses a
  star topology with the desktop PC as coordinator (`SessionManager`
  class) and mobile clients as data collectors (`CaptureService`). Each
  Android device maintains a TCP connection to the controller and handles
  local camera management, file I/O, and status reporting. The controller
  broadcasts start/stop commands via JSON messages and aggregates device
  status every 2 seconds. The system architecture has been validated with
  Samsung Galaxy S22 (Android 15) as the primary target platform, demonstrating reliable coordination up to 6 concurrent
  nodes on gigabit Wi-Fi (UniFi AP). Beyond 6 nodes, socket timeouts
  increased from 1.2s average to 4.8s average, affecting session
  reliability. The maximum tested configuration was 5 devices + 1 Shimmer
  sensor, limited by available hardware rather than architectural
  constraints.

- Timestamp Synchronisation Implementation: The system uses Chrony
  NTP server (`chrony.conf`: pool 2.android.pool.ntp.org iburst) for
  coarse clock alignment, followed by manual start triggers for fine
  synchronisation. Each device records `System.currentTimeMillis()` at
  session start, then applies linear interpolation for frame timestamps.
  Validation with GPS-locked reference clock showed 2.7 ms median drift
  across devices (IQR 1.8-4.2 ms, n=14 10-minute sessions). One failure
  mode: Wi-Fi roaming events caused 50-80 ms timestamp jumps in 3/14
  sessions, requiring manual session restart. The Shimmer3 uses its
  internal 32kHz crystal with ~±20ppm accuracy; cross-referencing with
  controller timestamps via Bluetooth message exchange showed 4.1 ms
  average offset (SD 2.3 ms). While achieving sub-5ms alignment, the
  system lacks hardware synchronisation triggers that would reduce drift
  to sub-millisecond levels.

- Camera Calibration Implementation: The calibration system
  (`CalibrationManager.py`, 284 lines) implements OpenCV-based intrinsic
  calibration using 9×6 checkerboard patterns [22]. For spatial alignment,
  RGB-thermal registration uses SIFT feature matching with RANSAC
  homography estimation (threshold 3.0 pixels). Typical calibration
  accuracy: RGB cameras achieve 0.31 pixel mean reprojection error,
  thermal cameras 0.89 pixels due to lower resolution. Cross-modal
  registration accuracy averages 2.1 pixel displacement (measured using
  heated calibration targets visible in both spectra). Temporal
  calibration uses manual sync markers (LED flash visible in both
  cameras) with frame-level alignment. One limitation: geometric
  distortion varies significantly between TopDon TC001 units; calibration
  coefficients require per-device determination and cannot be shared
  across identical camera models.

- TCP Socket Protocol Implementation: The networking layer uses
  Python `socketserver.ThreadingTCPServer` (port 8080) with JSON
  message protocol for device coordination [21]. Message types include:
  DEVICE_CONNECT, SESSION_START, STATUS_UPDATE, and DATA_STREAM with
  2-second heartbeat intervals. Client devices (`AndroidSocketClient.kt`,
  312 lines) maintain persistent connections with exponential backoff
  retry (initial 500ms, max 8s). During testing, socket reliability
  degraded beyond 50ms network RTT; 95th percentile message latency was
  23ms on local gigabit Ethernet, 187ms on office Wi-Fi. Connection
  recovery typically required 3-5 seconds after brief network
  interruptions. TLS implementation exists (`--enable-tls` flag) but
  increases message latency by ~12ms average. Device discovery relies on
  manual IP configuration; automatic mDNS discovery was implemented but
  removed due to unreliable performance across different network
  configurations.
  framework enables scalable multi-device recording and is a key
  technical contribution of the project.

- Qt5 Desktop Interface Implementation: The desktop controller
  (`MainWindow.py`, 487 lines) uses PyQt5 with custom widgets for device
  management, session control, and live status monitoring [17]. Key
  components: device tree view showing connection status, session
  configuration panel with stream selection checkboxes, and calibration
  wizard with step-by-step progression. The Android app
  (`MainActivity.kt`, 298 lines) implements Material Design with camera
  preview fragments and connection status indicators. Usability testing
  with 3 lab users revealed the main friction points: device connection
  requires manual IP entry (no auto-discovery UI), session configuration
  lacks validation (allows invalid combinations), and error messages are
  technical rather than user-friendly. Average setup time for experienced
  users: 4.2 minutes; for new users: 12.8 minutes with brief training.
  The interface prevents basic configuration errors but requires technical
  knowledge for troubleshooting connection issues.

## Evaluation of Objectives and Outcomes

## Evaluation Against Project Objectives

Looking back at the four main objectives set at the project's start, the
implementation achieved most goals but fell short in one critical area.
Here's what was actually accomplished versus what was planned:

Objective 1: Integrated Multi-Device Platform

The core platform works as intended. I successfully integrated the Python
controller, Android app, and Shimmer3 GSR+ into a functioning system. During the final demonstration on 2024-12-15,
we recorded synchronised 1080p RGB video, 320×240 thermal imagery, and
128Hz GSR data from 3 Samsung devices simultaneously for a 12-minute
session. All files were properly timestamped and saved to the designated
output folders (`/recordings/session_20241215_1430/`). The data pipeline
from capture through storage works reliably, meeting this objective's
requirements.

Objective 2: Sub-5ms Timing Precision

The synchronisation system performs better than initially expected. I
measured 2.7ms median drift across 4 devices using a GPS-locked reference
clock over 14 test sessions. This exceeds the original ±5ms tolerance
requirement. However, one significant failure mode emerged: Wi-Fi roaming
events can cause 50-80ms timestamp jumps, which happened in 3 out of 14
longer test sessions. I implemented Chrony NTP server with manual session
triggers to achieve this precision, documented in `sync_protocol.md`.
Overall, this objective was achieved for the target use case.

Objective 3: User-Friendly Research Tool

This is where I encountered the most significant shortfall. While the core
functionality works, usability testing with 3 lab members revealed
substantial friction. The desktop GUI (`MainWindow.py`) becomes
unresponsive during device discovery operations, forcing users to restart
the application. Device connection requires manual IP address entry since
automatic discovery proved unreliable on our departmental Wi-Fi network.
New users averaged 12.8 minutes for initial session setup versus my
target of under 5 minutes. The Android interface works better but lacks
error recovery—if a connection drops, users must manually restart the
app. While the system allows single-operator control of multiple devices,
it's not yet intuitive enough for non-technical researchers to use
independently.

Objective 4: Pilot Study Validation

This objective was not achieved. I planned to conduct a small pilot study
with 5-8 participants to validate the contactless GSR measurement
hypothesis, but several factors prevented this:
- Hardware delivery delays (thermal camera arrived 3 weeks late)  
- Persistent UI stability issues that would have compromised data quality
- Time constraints in the final project phase
- Ethics approval timeline conflicts with development schedule

The lack of pilot data means I cannot demonstrate the system's
effectiveness for actual contactless GSR measurement—only that the
technical infrastructure works. This represents a significant gap that
limits the project's validation.

## System Limitations and Failure Modes

Several critical issues prevent the system from being deployment-ready.
These limitations became apparent during testing and would need resolution
before any real research use:

UI Thread Blocking and Application Crashes

The Qt5 desktop controller suffers from frequent UI freezes when handling
device connections. On 2024-12-10 14:23, during a 4-device connection
test, the application became unresponsive for 8 seconds when clicking
"Refresh Devices" while background socket operations were active. This
happens because device discovery runs on the main UI thread
(`DeviceManager.scan_network()` in `MainWindow.py:342`). The application
requires force-quit and restart approximately once every 3-4 session
attempts. Error logs show `QApplication: exec: Cannot be called from a
worker thread` when trying to update device status indicators during
active network operations.

Network Discovery Failures Under Real Conditions

Device auto-discovery fails consistently on enterprise Wi-Fi networks. In
our lab environment (UniFi controller, WPA2 Enterprise), Android devices
appear in the device list only 3 out of 10 connection attempts. Manual IP
address entry works but defeats the plug-and-play goal. On 2024-12-08
15:41, device Samsung_S22 (IP 192.168.1.107) remained "Connecting..." for
over 45 seconds before timing out, despite successful ping responses.
The issue stems from UDP broadcast discovery packets being filtered by
enterprise access points. Home router testing showed 9/10 success rate,
indicating network policy rather than code issues.

Shimmer3 Bluetooth Reliability Issues

The Shimmer3 GSR+ sensor disconnects unpredictably during longer sessions.
Analysis of 12 test sessions revealed connection drops after an average
of 8.3 minutes (range 4-18 minutes). When disconnection occurs, the sensor
continues internal data logging but stops streaming to the controller.
Recovery requires manual power cycle of the Shimmer device—automatic
reconnection fails due to the device entering a locked Bluetooth state.
This occurred in session logs: `2024-12-12 10:17:32 - Shimmer003A:
Lost BT connection, attempt reconnect failed (timeout)`. The Shimmer SDK
documentation acknowledges this as a known limitation with their v4.1
firmware [8].

Cross-Platform File System Limitations

File path handling differs between Windows and Android, causing data loss
in mixed environments. The system uses forward slashes for file paths in
JSON configurations, which works on Android but fails on Windows when the
controller runs on a Windows PC while devices use Android. On 2024-12-09,
session data from 2 Android devices was lost because the Windows
controller could not parse their file paths (`/storage/emulated/0/` vs
`C:\recordings\`). I implemented basic path conversion but it's fragile
and fails when users rename default directories.

These aren't minor bugs—they're fundamental reliability issues that would
undermine any serious research use of the system.

## Specific Technical Improvements Needed

Rather than generic "future work," here are the concrete next steps based
on failure analysis:

UI Threading and Responsiveness (Target: 2 weeks)

Move all network operations to background threads using `QThread` and
implement proper signal-slot communication for UI updates. The specific
changes needed:
- Refactor `DeviceManager.scan_network()` to use `QNetworkAccessManager`
  with async callbacks
- Implement connection status updates via `pyqtSignal` emissions
- Add connection timeout handling (currently hard-coded 30s, should be 5s)
- Replace blocking socket calls in `SessionManager.py` with non-blocking
  alternatives

Success criteria: No UI freezes during 10 consecutive device connection
attempts.

mDNS-Based Device Discovery (Target: 1 week)

Replace UDP broadcast with Zeroconf/mDNS using the `python-zeroconf`
library [19]. Android devices would register as `_bucika._tcp.local` services
with device capabilities in TXT records. This bypasses enterprise Wi-Fi
filtering issues since mDNS uses multicast rather than broadcast.
Implementation estimate: ~150 lines in `DiscoveryService.py` plus
corresponding Android `NsdManager` integration.

Shimmer SDK Replacement (Target: 3 weeks)

The Shimmer SDK's Bluetooth reliability issues require replacing their
high-level API with direct RFCOMM socket communication. I tested this
approach with a minimal Python implementation using `pybluez` and achieved
stable 15-minute sessions by implementing custom heartbeat packets every
2 seconds. This requires reverse-engineering their data packet format
(partially documented in their GitHub issues), but eliminates dependency
on their problematic SDK.

Hardware GSR Sync Trigger (Target: 1 week + hardware order)

Replace software timestamps with hardware sync using an Arduino Nano
connected to the desktop controller via USB serial. The Arduino would
output 3.3V TTL pulses to trigger simultaneous recording on all devices.
Estimated improvement: sub-200µs synchronisation accuracy vs current 2-3ms.
Required hardware: 1x Arduino Nano, 5x optocouplers, basic PCB
($47 total cost).

Contactless GSR Algorithm Development (Target: 6-8 weeks)

With reliable data collection, I can focus on the core research question.
Initial approach: extract thermal features from palmar regions
(temperature gradients, perspiration patterns) and correlate with Shimmer
GSR readings using ridge regression. Target dataset: 20 participants ×
10-minute sessions with controlled stress stimuli (Trier Social Stress
Test protocol). Success metric: R² > 0.6 correlation between predicted
and actual GSR peaks.

These are specific, implementable plans rather than aspirational goals.

## Code and Data Availability

Repository Structure and Build Instructions

The complete system is available in the GitHub repository with comprehensive build and deployment instructions. Complete build procedures, dependency management, and configuration details are provided in Appendix H.1.

Hardware Specifications and Configuration Files

Detailed hardware specifications, tested configurations, and complete configuration file templates are documented in Appendix H.2.

Test Data and Validation Results

Comprehensive test datasets, validation methodologies, and performance benchmarks are documented in Appendix H.3. Missing: No human participant data due to lack of pilot study.

Reproducibility Verification

Complete replication procedures and validation scripts are provided in Appendix H.4. The system can be reproduced from these artifacts, though UI stability issues will require the specific hardware/software versions documented in the appendix.

## References

See [centralised references](references.md) for all citations used throughout this thesis.
