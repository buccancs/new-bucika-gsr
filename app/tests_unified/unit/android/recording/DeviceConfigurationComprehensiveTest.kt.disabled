package com.multisensor.recording.recording

import android.content.Context
import com.multisensor.recording.calibration.CalibrationCaptureManager
import com.multisensor.recording.recording.DeviceConfiguration.SensorChannel
import com.multisensor.recording.service.SessionManager
import com.multisensor.recording.util.Logger
import io.mockk.*
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.robolectric.annotation.Config
import java.io.File

<<<<<<<< HEAD:AndroidApp/src/test/disabled_tests/DeviceConfigurationComprehensiveTest.kt
========
/**
 * Comprehensive Device Configuration Tests
 * =======================================
 * 
 * This test class provides comprehensive testing for device configuration
 * management, sensor setup, and recording coordination.
 * 
 * Test coverage:
 * - Device initialization and setup
 * - Sensor channel configuration
 * - Recording state management
 * - Error handling and recovery
 * - Performance monitoring
 * 
 * Author: Multi-Sensor Recording System
 * Date: 2025-01-16
 */
@RunWith(RobolectricTestRunner::class)
>>>>>>>> master:AndroidApp/src/test/java/com/multisensor/recording/recording/DeviceConfigurationComprehensiveTest.kt.disabled
@Config(sdk = [28])
@ExperimentalCoroutinesApi
class DeviceConfigurationComprehensiveTest {

    private lateinit var mockContext: Context
    private lateinit var mockSessionManager: SessionManager
    private lateinit var mockLogger: Logger
    private lateinit var deviceConfiguration: DeviceConfiguration

    @BeforeEach
    fun setup() {
        mockContext = mockk(relaxed = true)
        mockSessionManager = mockk(relaxed = true)
        mockLogger = mockk(relaxed = true)

        deviceConfiguration = DeviceConfiguration(mockContext, mockLogger)
    }

    @AfterEach
    fun tearDown() {
        clearAllMocks()
    }

    @Test
    fun `device configuration initialization should succeed`() = runTest {
        assertNotNull("DeviceConfiguration should be created", deviceConfiguration)
        assertTrue("Device should be initializable", deviceConfiguration.initialize())

        verify { mockLogger.info("Initializing device configuration...") }
    }

    @Test
    fun `sensor channels should be configured correctly`() = runTest {
        val testChannels = listOf(
            SensorChannel.GSR,
            SensorChannel.PPG,
            SensorChannel.ACCELEROMETER_X,
            SensorChannel.ACCELEROMETER_Y,
            SensorChannel.ACCELEROMETER_Z
        )
        
        val result = deviceConfiguration.configureSensorChannels(testChannels)

        assertTrue("Sensor channels should be configured successfully", result)
        assertEquals("All channels should be configured", testChannels.size, 
                    deviceConfiguration.getConfiguredChannels().size)
        
        testChannels.forEach { channel ->
            assertTrue("Channel $channel should be configured", 
                      deviceConfiguration.isChannelConfigured(channel))
        }
    }

    @Test
    fun `device status tracking should work correctly`() = runTest {
        assertEquals("Initial status should be IDLE", 
                    DeviceConfiguration.DeviceStatus.IDLE, 
                    deviceConfiguration.getDeviceStatus())
        
        deviceConfiguration.setDeviceStatus(DeviceConfiguration.DeviceStatus.INITIALIZING)
        assertEquals("Status should update to INITIALIZING", 
                    DeviceConfiguration.DeviceStatus.INITIALIZING,
                    deviceConfiguration.getDeviceStatus())

        deviceConfiguration.setDeviceStatus(DeviceConfiguration.DeviceStatus.READY)
        assertEquals("Status should update to READY", 
                    DeviceConfiguration.DeviceStatus.READY,
                    deviceConfiguration.getDeviceStatus())

        deviceConfiguration.setDeviceStatus(DeviceConfiguration.DeviceStatus.RECORDING)
        assertEquals("Status should update to RECORDING", 
                    DeviceConfiguration.DeviceStatus.RECORDING,
                    deviceConfiguration.getDeviceStatus())
    }

    @Test
    fun `sampling rate configuration should validate inputs`() = runTest {
        val validRates = listOf(50, 100, 200, 500, 1000)
        val invalidRates = listOf(-1, 0, 10000, 50000)
        
        validRates.forEach { rate ->
            val result = deviceConfiguration.setSamplingRate(rate)
            assertTrue("Sampling rate $rate should be valid", result)
            assertEquals("Sampling rate should be set correctly", rate, 
                        deviceConfiguration.getSamplingRate())
        }
        
        invalidRates.forEach { rate ->
            val result = deviceConfiguration.setSamplingRate(rate)
            assertFalse("Sampling rate $rate should be invalid", result)
        }
    }

    @Test
    fun `device calibration integration should work`() = runTest {
        val mockCalibrationManager = mockk<CalibrationCaptureManager>(relaxed = true)
        every { mockCalibrationManager.isCalibrationValid() } returns true
        every { mockCalibrationManager.getCalibrationData() } returns mapOf(
            "camera_matrix" to arrayOf(arrayOf(1000.0, 0.0, 320.0)),
            "rms_error" to 0.45
        )
        
        deviceConfiguration.setCalibrationManager(mockCalibrationManager)
        
        assertTrue("Device should accept valid calibration", 
                  deviceConfiguration.validateCalibration())
        
        val calibrationData = deviceConfiguration.getCalibrationData()
        assertNotNull("Calibration data should be available", calibrationData)
        assertTrue("Calibration data should contain camera matrix", 
                  calibrationData.containsKey("camera_matrix"))
    }

    @Test
    fun `performance metrics should be tracked`() = runTest {
        deviceConfiguration.initialize()
        
        repeat(10) {
            deviceConfiguration.recordPerformanceMetric("sensor_read", 1.5 + it * 0.1)
        }

        repeat(5) {
            deviceConfiguration.recordPerformanceMetric("data_process", 0.8 + it * 0.05)
        }
        
        val performanceMetrics = deviceConfiguration.getPerformanceMetrics()

        assertNotNull("Performance metrics should be available", performanceMetrics)
        assertTrue("Should have sensor_read metrics", 
                  performanceMetrics.containsKey("sensor_read"))
        assertTrue("Should have data_process metrics", 
                  performanceMetrics.containsKey("data_process"))
        
        val sensorReadMetrics = performanceMetrics["sensor_read"]!!
        assertEquals("Should have 10 sensor read samples", 10, sensorReadMetrics["count"])
        assertTrue("Average should be reasonable", 
                  sensorReadMetrics["average"] as Double > 1.0)
    }

    @Test
    fun `error handling should work correctly`() = runTest {
        val errorConditions = listOf(
            "SENSOR_CONNECTION_FAILED",
            "CALIBRATION_INVALID", 
            "SAMPLING_RATE_UNSUPPORTED",
            "MEMORY_ALLOCATION_FAILED"
        )

        errorConditions.forEach { errorCode ->
            val result = deviceConfiguration.handleError(errorCode, "Test error: $errorCode")

            assertTrue("Error $errorCode should be handled", result)
            verify { mockLogger.error(match { it.contains(errorCode) }) }
        }
        
        val errorHistory = deviceConfiguration.getErrorHistory()
        assertEquals("Should track all error conditions", 
                    errorConditions.size, errorHistory.size)
    }

    @Test
    fun `device synchronization should work`() = runTest {
        val masterTimestamp = System.currentTimeMillis()
        val deviceId = "test_device_001"
        
        val syncResult = deviceConfiguration.synchronizeWithMaster(masterTimestamp, deviceId)

        assertTrue("Synchronization should succeed", syncResult)
        
        val syncedTimestamp = deviceConfiguration.getSynchronizedTimestamp()
        assertTrue("Synchronized timestamp should be set", syncedTimestamp > 0)
        
        Thread.sleep(10)
        val clockDrift = deviceConfiguration.calculateClockDrift()
        assertTrue("Clock drift should be calculated", clockDrift >= 0)
    }

    @Test
    fun `configuration persistence should work`() = runTest {
        val testConfig = mapOf(
            "sampling_rate" to 1000,
            "device_id" to "test_device_001",
            "sensor_channels" to listOf("GSR", "PPG", "ACCEL_X", "ACCEL_Y", "ACCEL_Z"),
            "calibration_enabled" to true
        )
        
        val saveResult = deviceConfiguration.saveConfiguration(testConfig)
        assertTrue("Configuration should be saved successfully", saveResult)
        
        val loadedConfig = deviceConfiguration.loadConfiguration()
        assertNotNull("Configuration should be loaded", loadedConfig)
        
        assertEquals("Sampling rate should match", 
                    testConfig["sampling_rate"], loadedConfig["sampling_rate"])
        assertEquals("Device ID should match", 
                    testConfig["device_id"], loadedConfig["device_id"])
        assertEquals("Sensor channels should match", 
                    testConfig["sensor_channels"], loadedConfig["sensor_channels"])
    }

    @Test
    fun `device health monitoring should work`() = runTest {
        deviceConfiguration.initialize()
        
        deviceConfiguration.updateHealthMetric("cpu_usage", 25.5)
        deviceConfiguration.updateHealthMetric("memory_usage", 65.2)
        deviceConfiguration.updateHealthMetric("battery_level", 80.0)
        deviceConfiguration.updateHealthMetric("temperature", 42.5)
        
        val healthStatus = deviceConfiguration.getHealthStatus()

        assertNotNull("Health status should be available", healthStatus)
        assertTrue("Should include CPU usage", healthStatus.containsKey("cpu_usage"))
        assertTrue("Should include memory usage", healthStatus.containsKey("memory_usage"))
        assertTrue("Should include battery level", healthStatus.containsKey("battery_level"))
        assertTrue("Should include temperature", healthStatus.containsKey("temperature"))
        
        val overallHealth = deviceConfiguration.assessOverallHealth()
        assertTrue("Overall health should be between 0 and 100", 
                  overallHealth in 0.0..100.0)
    }

    @Test
    fun `concurrent operations should be handled safely`() = runTest {
        val threads = mutableListOf<Thread>()

        repeat(5) { threadId ->
            val thread = Thread {
                repeat(10) { iteration ->
                    deviceConfiguration.updateHealthMetric(
                        "thread_${threadId}_metric", 
                        (threadId * 10 + iteration).toDouble()
                    )

                    deviceConfiguration.recordPerformanceMetric(
                        "thread_${threadId}_operation", 
                        (iteration * 0.1)
                    )
                }
            }
            threads.add(thread)
            thread.start()
        }
        
        threads.forEach { it.join() }
        
        val healthStatus = deviceConfiguration.getHealthStatus()
        val performanceMetrics = deviceConfiguration.getPerformanceMetrics()
        
        assertTrue("Should have health metrics from all threads", 
                  healthStatus.size >= 5)
        assertTrue("Should have performance metrics from all threads", 
                  performanceMetrics.size >= 5)
    }

    @Test
    fun `resource cleanup should work correctly`() = runTest {
        deviceConfiguration.initialize()
        
        val resourceIds = mutableListOf<String>()
        repeat(5) { index ->
            val resourceId = "resource_$index"
            deviceConfiguration.allocateResource(resourceId, "test_resource_type")
            resourceIds.add(resourceId)
        }
        
        resourceIds.forEach { resourceId ->
            assertTrue("Resource $resourceId should be allocated", 
                      deviceConfiguration.isResourceAllocated(resourceId))
        }
        
        val cleanupResult = deviceConfiguration.cleanup()
        assertTrue("Cleanup should succeed", cleanupResult)
        
        resourceIds.forEach { resourceId ->
            assertFalse("Resource $resourceId should be released", 
                       deviceConfiguration.isResourceAllocated(resourceId))
        }

        verify { mockLogger.info("Device configuration cleanup completed") }
    }
}